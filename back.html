{{FrontSide}}

<!--
The Template is divided into sections.
Sections get turned off based on which Card Type is displayed.
-->

<div id=card-back>

<!-- Correct Answers Section -->
<!--For: Radical, Kanji, Vocabulary-->
<div>
	<br>Correct Answers<hr>
	<p id="correct"></p>
</div>

<!--Radical Combination Section-->
<!--For: Kanji-->
<div id=section-radical-combination>
	Radical Combination<hr>
	<div id=combination></div>
</div>

<!--Meaning Section-->
<!--For: Radical, Kanji, Vocabulary-->

<div id=section-meaning>
	<div id=meaning-title></div>
	<p id=meanings></p>
	<p class="explanation">Explanation</p>
	<div class="mnemonic">{{Meaning_Mnemonic}}</div>
	<div id="meaning-hint">
		<div class="mnemonic-hint">
			<p class="hint"><img src="_hint.png" width="12" height="12">
			<b style="vertical-align: top">HINTS</b><br></p>{{Meaning_Hint}}
		</div>
	</div>
</div>

<!--Reading Section-->
<!--For: Kanji, Vocabulary-->

<div id=section-reading>
	Reading<hr>
	<div id=vocabulary-reading>{{Reading}}</div>
	<div id=kanji-readings>
		<div id=reading-container>
			<div id=onyomi-readings>On’yomi<br>{{Reading_Onyomi}}</div>
			<div id=kunyomi-readings>Kun’yomi<br>{{Reading_Kunyomi}}</div>
			<div id=nanori-readings>Nanori<br>{{Reading_Nanori}}</div>
		</div>
	</div>
	<div id="reading-audios">{{Audio}}</div>
	<p class="explanation">Explanation</p>
	<div class="mnemonic">{{Reading_Mnemonic}}</div>
	<div id="reading-hint">
		<div class="mnemonic-hint">
			<p class="hint"><img src="_hint.png" width="9" height="9">
			<b>HINTS</b><br></p>{{Reading_Hint}}
		</div>
	</div>
</div>

<!--Context Section-->
<!--For: Vocabulary-->
<div id=section-context>
	Context<hr>
	<div id="context-patterns">
		<div id="patterns-of-use">
			<p class="explanation">Patterns of Use</p>
		</div>
		<div id="common-word-combinations">
			<p class="explanation">Common Word Combinations</p>
		</div>
	</div>
	<p class="explanation">Context Sentences</p>
	<div id="context-sentences"></div>
</div>

<!--Box Section-->
<!--For: Radical, Kanji, Vocabulary-->
<div id=section-box>
	<div id=box-title></div>
	<div id=box-container></div>
</div>

<!--Phonetic-Semantic Composition Section-->
<!--For: Radical, Kanji-->
<div id=section-phonetic-semantic>
	Phonetic-Semantic Composition<hr>
	<p class="explanation" id=phonetic-semantic-description></p>
	<div id=phonetic-semantic-container>
		<div id=phonetic-container></div>
		<div id=compound-container></div>
	</div>
</div>

<!--Found in Vocabulary Section-->
<!--For: Kanji-->
<div id=section-found-in-vocabulary>
	Found in Vocabulary<hr>
	<div id=found-in-vocabulary-container></div>
</div>

</div> <!-- id=card-back -->

<!--SCRIPT: Slice meanings and insert into the Meaning Section.-->
<script>
var title = "Meaning<hr>";
if ("{{Card_Type}}" == "Radical") {
	var title = "Name<hr>";
}
var div = document.getElementById("meaning-title");
var element = document.createElement("p");
element.innerHTML = title;
div.appendChild(element);

var meanings = "{{Meaning}}";
var array = meanings.split(",");
var primary = array[0];
var alternative = array.splice(1);
var wordtype = "{{Word_Type}}";

var div = document.getElementById("meanings");
var element = document.createElement("p");
element.innerHTML = "<b>PRIMARY </b>" + primary.toString().toUpperCase();
div.appendChild(element);

if (alternative.toString().length !== 0) {
	var element = document.createElement("p");
	element.innerHTML = "<b>ALTERNATIVE </b>" + alternative.toString().toUpperCase();
	div.appendChild(element);
}

if (wordtype.toString().length !== 0) {
	var element = document.createElement("p");
	element.innerHTML = "<b>WORD TYPE </b>" + wordtype.toString().toUpperCase();
	div.appendChild(element);
}
</script>

<!--SCRIPT: Disable unused Reading divisions.-->
<script>
if ("{{Card_Type}}" == "Kana_Vocabulary") {
	document.getElementsByClassName("explanation")[1].style.display = "none";
}

function disable_reading_div(id, readings) {
	var div = document.getElementById(id);
	if (readings === "") {
		div.style.display = "none";
	} else {
		div.style.display = "";
	}
}

disable_reading_div("onyomi-readings", `{{Reading_Onyomi}}`);
disable_reading_div("kunyomi-readings", `{{Reading_Kunyomi}}`);
disable_reading_div("nanori-readings", `{{Reading_Nanori}}`);
</script>

<!--SCRIPT: Disable unused Hint divisions.-->
<script>
function disable_hint_div(id, readings) {
	var div = document.getElementById(id);
	if (readings === "") {
		div.style.display = "none";
	} else {
		div.style.display = "";
	}
}

disable_hint_div("meaning-hint", `{{Meaning_Hint}}`);
disable_hint_div("reading-hint", `{{Reading_Hint}}`);
</script>

<!--SCRIPT: Slice and add Context Patterns -->
<script>
var combinations = `{{Context_Patterns}}`;
var combinationsarray = combinations.split("|");

for (var i = 1; i < 6; i+=2){
	var div = document.getElementById('common-word-combinations');
	var element = document.createElement("p");
	element.innerHTML = "<ja>" + combinationsarray[0].split(";")[i] + "</ja><br>" + combinationsarray[0].split(";")[i + 1];
	element.setAttribute("id", i);
	if (combinationsarray[0].split(";")[i] === undefined) {
		element.innerHTML = "<br>"; 
	}
	div.appendChild(element);
}

for (var i = 0; i < combinationsarray.length; i++){
	var div = document.getElementById("patterns-of-use")
	var element = document.createElement("div");
	element.innerHTML = "<button class=notclicked id=button name='" + i + "' onclick='Click()'>" + combinationsarray[i].split(";")[0] + "</button><br>";
	div.appendChild(element);
}

var element = document.getElementsByName('0')[0];
element.classList.add("notclicked");
element.classList.add("clicked");

function Click() {
	var z = event.target.name;

	for (var i = 0; i < combinationsarray.length; i++){
		var element = document.getElementsByName(i)[0]
		element.classList.remove("clicked");
		element.classList.add("notclicked");
	}

	var element = document.getElementsByName(event.target.name)[0]
	element.classList.add("clicked");
	element.classList.remove("notclicked");

	for (var i = 1; i < combinationsarray[z].length; i+=2){
		document.getElementById(i).innerHTML = "<ja>" + combinationsarray[z].split(";")[i] + "</ja><br>" + combinationsarray[z].split(";")[i + 1];
		if (combinationsarray[z].split(";")[i] === undefined) {
			document.getElementById(i).innerHTML = " ";
		}
	}	
}		
if (combinations.length === 0) {
	document.getElementById('context-patterns').innerHTML = " ";
}	
</script>

<!--SCRIPT: Slice and add context sentences.-->
<script>
if ("{{Card_Type}}" == "Vocabulary" || "{{Card_Type}}" == "Kana_Vocabulary") {
	var sentences = `{{Context_Sentences}}`;
	var array = sentences.split("|");

	var div = document.getElementById("context-sentences");

	function appendContextSentence(en, jp) {
		if (jp !== "") {
			var element = document.createElement("p");
			element.innerHTML = "<p><ja>" + jp + "</ja><br>" + en + "</p>";
			div.appendChild(element);
		}
	}
	appendContextSentence(array[0].toString(), array[1].toString());
	appendContextSentence(array[2].toString(), array[3].toString());
	appendContextSentence(array[4].toString(), array[5].toString());
}
</script>

<!--SCRIPT: Disable divisions.-->
<script>
var readingsection = document.getElementById("section-reading")
var meaningsection = document.getElementById("section-meaning")
var boxsection = document.getElementById("section-box")
var contextsection = document.getElementById("section-context")
var combinationsection = document.getElementById("section-radical-combination")
var foundinvocabularysection = document.getElementById("section-found-in-vocabulary")

if ("{{Card_Type}}" === "Radical") {
	readingsection.style.display = "none";
	contextsection.style.display = "none";
	combinationsection.style.display = "none";
	foundinvocabularysection.style.display = "none";
}
if ("{{Card_Type}}" === "Kanji") {
	contextsection.style.display = "none";
	compositionsection.style.display = "none";
}
if ("{{Card_Type}}" === "Vocabulary") {
	combinationsection.style.display = "none";
	foundinvocabularysection.style.display = "none";
}
if ("{{Card_Type}}" === "Kana_Vocabulary") {
	readingsection.style.display = "none";
	combinationsection.style.display = "none";
	foundinvocabularysection.style.display = "none";
	boxsection.style.display = "none";
}
</script>

<!--SCRIPT: Populate Box Characters (Found in Kanji, Visually Similar Kanji and Kanji Composition).-->
<script>
if ("{{Card_Type}}" == "Radical") {
	var character = "{{Found_in_Characters}}";
	var characterarray = character.split(", ");
	var meaning = "{{Found_in_Meaning}}";
	var meaningarray = meaning.split(", ");
	var reading = "{{Found_in_Reading}}";
	var readingarray = reading.split(", ");

	if (character.toString().length !== 0) {
		var div = document.getElementById("box-title")
		var element = document.createElement("div");
		element.innerHTML = "Found In Kanji<hr>";
		div.appendChild(element);

		for (var i = 0; i < characterarray.length; i++) {
			var div = document.getElementById("box-container")
			var element = document.createElement("div");
			element.innerHTML = "<div id=box-character>" + characterarray[i] + "<div id=box-meaning>" + readingarray[i] + "<br>" + meaningarray[i] + "</div></div>";
			div.appendChild(element);
		}
	}
} else if ("{{Card_Type}}" == "Kanji") {
	var character = "{{Similar_Characters}}";
	var characterarray = character.split(", ");
	var meaning = "{{Similar_Meaning}}";
	var meaningarray = meaning.split(", ");
	var reading = "{{Similar_Reading}}";
	var readingarray = reading.split(", ");

	if (character.toString().length !== 0) {
		var div = document.getElementById("box-title")
		var element = document.createElement("div");
		element.innerHTML = "Visually Similar Kanji<hr>";
		div.appendChild(element);

		for (var i = 0; i < characterarray.length; i++) {
			var div = document.getElementById("box-container");
			var element = document.createElement("div");
			element.innerHTML = "<div id=box-character>" + characterarray[i] + "<div id=box-meaning>" + readingarray[i] + "<br>" + meaningarray[i].toString().substring(0, 15) + "</div></div>";
			div.appendChild(element);
		}
	}
} else if ("{{Card_Type}}" == "Vocabulary") {
	var character = `{{Components_Characters}}`;
	var characterarray = character.split(", ");
	var meaning = "{{Components_Meaning}}";
	var meaningarray = meaning.split(", ");
	var reading = "{{Components_Reading}}";
	var readingarray = reading.split(", ");

	if (character.toString().length !== 0) {
		var div = document.getElementById("box-title")
		var element = document.createElement("div");
		element.innerHTML = "Kanji Composition<hr>";
		div.appendChild(element);

		for (var i = 0; i < characterarray.length; i++) {
			var div = document.getElementById("box-container")
			var element = document.createElement("div");
			element.innerHTML = "<div id=box-character>" + characterarray[i] + "<div id=box-meaning>" + readingarray[i] + "<br>" + meaningarray[i].toString().substring(0, 15) + "</div></div>";
			div.appendChild(element);
		}
	}
}
</script>

<!--SCRIPT: Add Phonetic-Semantic Composition Characters.-->
<script>
if ("{{Card_Type}}" == "Kanji" || "{{Card_Type}}" == "Radical") {
	var sections = `{{Keisei}}`;
	var sectionarray = sections.split(" | ");
	var start = 1;
	var data = sectionarray[0].split(", ");
	var description = document.getElementById("phonetic-semantic-description");
	if (data[0] == "compound" || data[0] == "phonetic") {
		if (data[0] == "compound") {
			// Backticks needed for radicals with "
			description.innerHTML = "The kanji 「<ja>" + `{{Characters}}` + "</ja>」 was created using semantic-phonetic composition!<br><br>The phonetic component is 「<ja>" + data[2] + "</ja>」 with the ON reading(s) 「<ja>" + data[3] + "</ja>」 (including rare ones), and the semantic component is 「<ja>" + data[4] + "</ja>」.<br>"
		} else if (data[0] == "phonetic") {
			var description = document.getElementById("phonetic-semantic-description");
			if ("{{Card_Type}}" == "Kanji") {
				description.innerHTML = "The kanji 「<ja>" + `{{Characters}}` + "</ja>」 is used as a phonetic component in other compounds! Its ON reading(s) are 「<ja>" + data[3] + "</ja>」.<br>"
			} else {
				description.innerHTML = "The radical 「<ja>" + `{{Characters}}` + "</ja>」 is used as a phonetic component in other compounds! Its ON reading(s) are 「<ja>" + data[3] + "</ja>」.<br>"
			}
		}
		var div = document.getElementById("phonetic-container");
		var element = document.createElement("div");
		element.innerHTML = "<div id=phonetic-character>" + data[2] + "<div id=box-meaning>" + data[3].split("・")[0] + "<br>Phonetic</div></div>";
		div.appendChild(element);
		if (data[1].includes("R")) {
			var element = document.createElement("div");
			element.innerHTML = "<div id=radical-character>" + data[2] + "<div id=box-meaning>" + data[3].split("・")[0] + "<br>" + sectionarray[start] + "</div></div>";
			div.appendChild(element);
			start += 1;
		}
		if (data[1].includes("K")) {
			var element = document.createElement("div");
			element.innerHTML = "<div id=box-character>" + data[2] + "<div id=box-meaning>" + sectionarray[start].split(", ")[1] + "<br>" + sectionarray[start].split(", ")[0] + "</div></div>";
			div.appendChild(element);
			start += 1;
		}
		var div = document.getElementById("compound-container");
		for (var i = start; i < sectionarray.length; i++) {
			var parts = sectionarray[i].split(", ");
			var element = document.createElement("div");
			element.innerHTML = "<div id=box-character>" + parts[0] + "<div id=box-meaning>" + parts[1] + "<br>" + parts[2] + "</div></div>";
			div.appendChild(element);
		}
	} else if (data[0] == "unprocessed") {
		description.innerHTML = "The kanji 「<ja>" + `{{Characters}}` + "</ja>」 has not been added to the WK Userscripts Keisei DB yet, please wait for a future version.<br>";
	} else if (data[0] == "nonradical") {
		description.innerHTML = "The radical 「<ja>" + `{{Characters}}` + "</ja>」 is not considered a phonetic mark!<br>";
	} else if (data[0] == "unknown") {
		description.innerHTML = "The kanji 「<ja>" + `{{Characters}}` + "</ja>」 has an unknown or contested origin, or its phonetic mark is too obscure to be useful. Stay tuned for more information in future versions of WK Userscripts Keisei.";
	} else {
		description.innerHTML = "The kanji 「<ja>" + `{{Characters}}` + "</ja>」 is not considered a semantic-phonetic composition.<br>Note: {{Keisei}}<br>";
	}
} else {
	var section = document.getElementById("section-phonetic-semantic");
	section.style.display = "none";
}
</script>

<!--SCRIPT: Add Radical Combination Characters.-->
<script>
if ("{{Card_Type}}" == "Kanji") {
	var character = `{{Components_Characters}}`;
	var characterarray = character.split(", ");
	var meaning = "{{Components_Meaning}}";
	var meaningarray = meaning.split(", ");
	
	for (var i = 0; i < meaningarray.length; i++){
		var div = document.getElementById("combination")
		var element = document.createElement("div");
	
		element.innerHTML = "<radical-combination>"+ characterarray[i] + "</radical-combination>" + "" + meaningarray[i].toString().substring(0, 15) + "";
		div.appendChild(element);
	
		if (i + 1 != characterarray.length) {
			var div = document.getElementById("combination")
			var element = document.createElement("p");
			element.innerHTML = "<div class=combination-plus><b>+<b/></div>";
			div.appendChild(element);
		}
	}
}
</script>

<!--SCRIPT: Add Found in Vocabulary Characters.-->
<script>
if ("{{Card_Type}}" == "Kanji") {
	var character = "{{Found_in_Characters}}";
	var characterarray = character.split(", ");
	var meaning = "{{Found_in_Meaning}}";
	var meaningarray = meaning.split(", ");
	var reading = "{{Found_in_Reading}}";
	var readingarray = reading.split(", ");
	
	for (var i = 0; i < characterarray.length; i++){
		var div = document.getElementById("found-in-vocabulary-container")
		var element = document.createElement("div");
		element.innerHTML = "<div id=found-in-vocabulary-box><div class=found-in-voc>"+ characterarray[i] +"</div><div class=found-in-voc-reading>" + readingarray[i] +"<br>" + meaningarray[i] +"</div></div>";
		div.appendChild(element);
	}
	
	if (character.toString().length == 0) {
		var foundinvocabularysection = document.getElementById("section-found-in-vocabulary")
		foundinvocabularysection.style.display = "none";
	}
}
</script>

<!--SCRIPT: Check the answer -->
<script>
//some addons read the script too early:
if (document.getElementById("typeans")) {
	var typedAnswer = "";
	var typedAnswer_element = document.getElementById("typeans");
	if (typedAnswer_element) {
		typedAnswer_element.innerHTML = typedAnswer_element.innerHTML.replace(/<br.*/, "");
		typedAnswer_element.querySelectorAll(".typeGood, .typeBad").forEach((e) => {
			if (e.innerHTML == "-") return;
			typedAnswer += e.innerHTML;
		});
	}
	var typedAnswerLower = typedAnswer.replace(/'/).toLowerCase();
	var meaningWhitelist = `{{Meaning_Whitelist}}`.replace(/'/).toLowerCase().split(", ");
	var readingWhitelist = `{{Reading_Whitelist}}`.toLowerCase().split(", ");
} else {
	var typedAnswerLower = "";
}

var meaningWhitelist = `{{Meaning_Whitelist}}`.toLowerCase().split(", ");
var readingWhitelist = `{{Reading_Whitelist}}`.toLowerCase().split(", ");
var correctAnswers = [];
var correctText = document.getElementById("correct");

if (`{{Card}}` === "Meaning") {
	var capitalize = (array) => (array.map((elem) => (elem.trimRight().replace(/(^| )\w/g, c => c.toUpperCase()))));

	correctAnswers = `{{Meaning}}`.toLowerCase().split(", ");
	var accepted = [];
	var alternative = capitalize(`{{Meaning}}`.toLowerCase().split(", ").splice(1));
	meaningWhitelist.forEach((correct) => {
		if (!correctAnswers.includes(correct)) {
			correctAnswers.push(correct);
			accepted.push(correct);
		}
	});

	var meanings = capitalize(correctAnswers);
	accepted = capitalize(accepted);

	correctText.innerHTML = "Primary: <b>" + meanings[0] + "</b>";
	if (meanings.length > 1) {
		correctText.innerHTML += "<br>Alternative: <b>" + alternative.join(", ") + "</b>";
	}
	if (accepted.length > 0) {
		correctText.innerHTML += "<br>Accepted: <b>" + accepted.join(", ") + "</b>";
	}
} else if (`{{Card}}` === "Reading") {
	correctAnswers = readingWhitelist;
	var items = [];
	correctAnswers.forEach((x) => {
		items.push("<reading>" + x + "</reading>");
	});
	correctText.innerHTML = items.join(" ");
} else if (`{{Card}}` === "Characters") {
	var parts = `{{Character_Whitelist}}`.split(" | ");
	var lines = [];
	parts.forEach((x) => {
		answers = x.split(", ");
		correctAnswers = correctAnswers.concat(answers);
		var name = (`{{Card_Type}}` === "Kanji") ? "kanji" : "vocab";
		var text = "<p><characters class=\"correct-" + name + "\">" + answers.shift() + "</characters> - Reading";
		if (answers.length > 1) {
			text += "s";
		}
		text += ": ";
		answers.forEach((x) => {
			text += "<reading>" + x + "</reading> ";
		});
		lines.push(text);
	});
	correctText.innerHTML = lines.join("</p><p>") + "</p>";
}

if (typedAnswerLower != "") {
	var answerDiv = document.createElement("div");
	answerDiv.setAttribute("id", "typeans");
	answerDiv.innerHTML = typedAnswer;
	if (`{{Card}}` !== "Meaning") {
		answerDiv.style.fontFamily = "Hiragino Kaku Gothic Pro W3";
	}
	document.getElementById("typeans").replaceWith(answerDiv);

	if (typedAnswerLower === "") {
		answerDiv.style.display = "none";
	} else if (correctAnswers.includes(typedAnswerLower)) {
		answerDiv.classList.add("correct");
	} else {
		answerDiv.classList.add("incorrect");
	}
} else {
	document.getElementsByClassName("input")[0].style.display = "none";
	document.getElementsByClassName("input")[0].style.display = "none";
}
</script>

<!-- Generate tooltips -->
<script>
function setTooltips(tags, text) {
	for (var i = 0; i < tags.length; i++) {
		tags[i].setAttribute("title", text);
	}
}

var kanji = document.getElementsByTagName("kanji");
var radicals = document.getElementsByTagName("radical");
var vocab = document.getElementsByTagName("vocabulary");
var reading = document.getElementsByTagName("reading");

setTooltips(kanji, "Kanji");
setTooltips(radicals, "Radical");
setTooltips(vocab, "Vocabulary");
setTooltips(reading, "Reading");
</script>

<!-- Pitch Accent Info -->
<script>
	var characters = `{{Characters}}`;
	var readings = `{{Reading}}`;
	readings = readings.split(",").map(function (r) {
		return r.trim();
	});
	var readingsContainer = document.createElement("div");
	readingsContainer.id = "vocabulary-readings-container";
	readings.map(function (r, i) {
		var _c = document.createElement("div");
		_c.id = "reading-" + (i + 1);
		_c.classList.add("vocabulary-reading-entry");
		_c.innerHTML = r;
		readingsContainer.appendChild(_c);
	});
	document
		.getElementById("vocabulary-reading")
		.replaceChildren(readingsContainer);

	var SHOW_PITCH_DESCRIPTION = true;
	var SQUASH_DIGRAPHS = false;
	var PRE_PARSE = false; // load entire "accents.txt" into an object for faster lookup (true: lookup takes ~0.06ms; false: lookup takes ~0.5ms)
	var DOT_RADIUS = 0.2;
	var STROKE_WIDTH = 0.1;

	var WEB_URL =
		"http://www.gavo.t.u-tokyo.ac.jp/ojad/search/index/curve:fujisaki/word:%s";
	var digraphs = "ぁぃぅぇぉゃゅょゎゕゖァィゥェォャュョヮヵヶ";

	var pitchLookup = null;

	// Get the color and the pitch pattern name
	var patternObj = {
		heiban: {
			name: "平板",
			nameEng: "heiban",
			cssClass: "heiban",
			color: "#d20ca3",
		},
		odaka: {
			name: "尾高",
			nameEng: "odaka",
			cssClass: "odaka",
			color: "#0cd24d",
		},
		nakadaka: {
			name: "中高",
			nameEng: "nakadaka",
			cssClass: "nakadaka",
			color: "#27a2ff",
		},
		atamadaka: {
			name: "頭高",
			nameEng: "atamadaka",
			cssClass: "atamadaka",
			color: "#EA9316",
		},
		unknown: {
			name: "不詳",
			nameEng: "No pitch value found, click the number for more info.",
			cssClass: "unknown",
			color: "#CCCCCC",
		},
	};

	var JAPANESE_TO_WORD_TYPE = {
		名: "Noun",
		代: "Pronoun",
		副: "Adverb",
		形動: "な Adjective",
		感: "Interjection",
	};
	
	if (`{{Card_Type}}` == "Vocabulary" || `{{Card_Type}}` == "Kana_Vocabulary") {
		injectPitchInfo();
		addCss();
	}

	function injectPitchInfo() {
		document.querySelectorAll('.vocabulary-reading-entry').forEach(pReading => {
			let reading = pReading.textContent;
			getPitchInfo(characters, reading).then(function(pitchInfo){
				if (!pitchInfo) return;
				let dInfo = null;
				let wordTypes = [
					...new Set(
						[...pitchInfo.matchAll(/[\(;]([^\);]*)/g)].flatMap(
							(r) => r[1]
						)
					),
				];
				if (wordTypes.length > 0) {
					let wordTypeToPitch = wordTypes.map((w) => [w, [ ...pitchInfo.matchAll(new RegExp(w + "[^\\)]*\\)([\\d,]+)", "g") )]
						.flatMap((r) => r[1])
						.join("")
						.split(",")
						.filter((p) => p)
						.map((p) => parseInt(p))
					]);
					dInfo = appendPitchPatternInfo( pReading, pitchByWordTypeToInfoElements(wordTypeToPitch,characters,reading));
					pitchInfo = [...new Set([...pitchInfo.matchAll(/\d/g)].map((r) => r[0]))].map((p) => parseInt(p));
				}else{
					pitchInfo = pitchInfo.split(",").map((p) => parseInt(p));
					dInfo = appendPitchPatternInfo(
						pReading,
						pitchToInfoElements(
							pitchInfo,
							characters,
							reading
						)
					);
				}
				let diagrams = pitchInfo.map((p) => drawPitchDiagram(p, reading));
				pReading.before(...diagrams);
				makeMonospaced(pReading.childNodes[0]);
			});
		});
	}

	function pitchByWordTypeToInfoElements(wordTypeToPitch, vocab, reading) {
		let result = wordTypeToPitch.flatMap(([wordType, pitch]) => [
			`${JAPANESE_TO_WORD_TYPE[wordType]}: `,
			...pitchToInfoElements(pitch, vocab, reading),
			", ",
		]);
		result.pop();
		return result;
	}

	function pitchToInfoElements(pitch, vocab, reading) {
		return pitch.flatMap((p, i) => [
			i === 0 ? "" : " or ",
			generatePatternText(p, vocab, reading),
		]);
	}

	function appendPitchPatternInfo(readingElement, infoElements) {
		if (!SHOW_PITCH_DESCRIPTION) return null;
		let dInfo = document.createElement("div");
		let hInfo = document.createElement("h3");
		let pInfo = document.createElement("p");
		hInfo.textContent = "Pitch Pattern";
		dInfo.classList.add("pitch-pattern");
		pInfo.append(...infoElements);
		dInfo.append(hInfo, pInfo);
		readingElement.after(dInfo);
		return dInfo;
	}

	function loadPitchInfo(){
		return new Promise(function (resolve, reject) {
			if (pitchLookup) return resolve(pitchLookup);

			const lookupObject = JSON.parse(`{{Pitch_Accent}}`);
			pitchLookup = (vocab, reading) =>
				pitchLookupObject(vocab, reading, lookupObject);
			return resolve(pitchLookup);
		});
	}

	function pitchLookupObject(vocab, reading, lookupObject) {
		return lookupObject[vocab + "|" + reading];
	}

	function getPitchInfo(vocab, reading) {
		return new Promise(function (resolve, reject) {
			loadPitchInfo().then(function(pitchLookup){
				let result = pitchLookup(vocab, reading);
				if (!result)
					result = pitchLookup(
						vocab.replace(/する$/, ""),
						reading.replace(/する$/, "")
					);
				if (!result)
					result = pitchLookup(toHiragana(vocab), toHiragana(reading));
				if (!result)
					result = pitchLookup(toKatakana(vocab), toKatakana(reading));
				return resolve(result);
			}).catch(console.error);
		});
	}

	function toHiragana(kana) {
		let arr = [...kana];
		return arr
			.map((c) => c.charCodeAt(0))
			.map((c) => (12449 <= c && c <= 12534 ? c - 96 : c))
			.map((c) => String.fromCharCode(c))
			.join("");
	}

	function toKatakana(kana) {
		let arr = [...kana];
		return arr
			.map((c) => c.charCodeAt(0))
			.map((c) => (12353 <= c && c <= 12438 ? c + 96 : c))
			.map((c) => String.fromCharCode(c))
			.join("");
	}

	function getPitchType(pitchNum, moraCount) {
		if (pitchNum == 0) return patternObj.heiban;
		if (pitchNum == 1) return patternObj.atamadaka;
		if (pitchNum == moraCount) return patternObj.odaka;
		if (pitchNum < moraCount) return patternObj.nakadaka;
		return patternObj.unknown;
	}

	function getMoraCount(reading) {
		return [...reading].filter((c) => !digraphs.includes(c)).length;
	}

	function drawPitchDiagram(pitchNum, reading) {
		let moraCount = getMoraCount(reading);
		let width = SQUASH_DIGRAPHS ? moraCount : reading.length;
		let patternType = getPitchType(pitchNum, moraCount);

		let namespace = "http://www.w3.org/2000/svg";
		let svg = document.createElementNS(namespace, "svg");
		svg.setAttribute("viewBox", `-0.5 -0.25 ${width + 1} 1.5`);

		let xCoords = [];
		for (let i = 0; i <= reading.length; i++) {
			// using "<=" to get additional iteration for particle node
			if (!SQUASH_DIGRAPHS && digraphs.includes(reading[i])) {
				xCoords[xCoords.length - 1] += 0.5;
			} else {
				xCoords.push(i);
			}
		}
		let yCoords = new Array(moraCount + 1).fill(null);
		yCoords = yCoords.map((_, i) => {
			if (pitchNum == 0) return i === 0 ? 1 : 0;
			if (i + 1 == pitchNum) return 0;
			if (i === 0) return 1;
			return i < pitchNum ? 0 : 1;
		});
		let points = yCoords.map((y, i) => ({ x: xCoords[i], y }));

		let polyline = document.createElementNS(namespace, "polyline");
		polyline.setAttribute("fill", "none");
		polyline.setAttribute("stroke", patternType.color);
		polyline.setAttribute("stroke-width", STROKE_WIDTH);
		polyline.setAttribute(
			"points",
			points.map((p) => `${p.x},${p.y}`).join(" ")
		);
		svg.appendChild(polyline);

		points.forEach((p, i) => {
			let isParticle = i === points.length - 1;
			let circle = document.createElementNS(namespace, "circle");
			circle.setAttribute(
				"fill",
				isParticle ? "#eeeeee" : patternType.color
			);
			circle.setAttribute(
				"stroke",
				isParticle ? "black" : patternType.color
			);
			circle.setAttribute(
				"stroke-width",
				isParticle ? STROKE_WIDTH / 2 : 0
			);
			circle.setAttribute("cx", p.x);
			circle.setAttribute("cy", p.y);
			circle.setAttribute("r", DOT_RADIUS);
			svg.appendChild(circle);
		});
		let p = document.createElement("p");
		p.classList.add("pitch-diagram");
		p.lang = "ja"; // to match the WK CSS selector containing the reading font size
		p.appendChild(svg);
		return p;
		return svg;
	}

	function generatePatternText(pitchNum, vocab, reading) {
		let moraCount = getMoraCount(reading);
		let patternType = getPitchType(pitchNum, moraCount);
		let sName = document.createElement("span");
		let aLink = document.createElement("a");
		aLink.href = WEB_URL.replace("%s", vocab);
		aLink.target = "_blank";
		aLink.title = `Pitch Pattern: ${patternType.nameEng} (${patternType.name})`;
		aLink.textContent = `[${pitchNum}]`;
		sName.textContent = patternType.name + " ";
		sName.classList.add(patternType.cssClass);
		sName.appendChild(aLink);
		return sName;
	}

	function makeMonospaced(textNode) {
		let characters = [...textNode.textContent];
		if (SQUASH_DIGRAPHS) {
			characters.forEach((c, i, a) => {
				if (digraphs.includes(c)) a[i - 1] += c;
			});
			characters = characters.filter((c) => !digraphs.includes(c));
		}
		let spans = characters.map((c) => {
			let span = document.createElement("span");
			span.textContent = c;
			span.classList.toggle("digraph", c.length > 1);
			return span;
		});
		textNode.replaceWith(...spans);
	}

	function addCss() {
		let style = document.createElement("style");
		style.textContent = `
		#vocabulary-readings-container svg							{ height: 1.5em; width: auto; display: block; }
		.vocabulary-reading											{padding: 10px 0; }
		.vocabulary-reading-entry									{ line-height: 2.2em; margin: 0; }
		.vocabulary-reading-entry span								{ width: 1em; display: inline-block; text-align: center; white-space: nowrap; }
		.vocabulary-reading-entry span.digraph						{ font-feature-settings: 'hwid' on; }
		.pitch-pattern												{ display: flex; margin-bottom: 0; color: #999; text-transform: uppercase; }
		.pitch-pattern h3, #item-info .pitch-pattern h3				{ margin: 0 1em 0 0; padding: 0; font-size: 11px; font-weight: bold; letter-spacing: 0; border-bottom: none; line-height: 1.6em; }
		.pitch-pattern p											{ font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; font-size: 11px; flex: 1 0 auto; margin: 0; }
		.pitch-diagram												{ margin: 0; display: block; }
		.pitch-pattern + .pitch-diagram								{ margin-top: 0.6em; }
		${Object.values(patternObj)
			.map(({ color, cssClass }) => `.${cssClass} { color: ${color}; }`)
			.join("")}`;
		document.head.appendChild(style);
	}
</script>
